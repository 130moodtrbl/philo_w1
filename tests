#include "../inc/philo.h"

int	philo_has_starved(t_philos *philo)
{
	long	curr;
	int		has_starved;

	curr = current_time();
	pthread_mutex_lock(philo->lock_last_meal);
	has_starved = (curr - philo->last_meal >= philo->time_to_die);
	pthread_mutex_unlock(philo->lock_last_meal);
	return (has_starved);
}

int	philo_has_died(t_philos *philo)
{
	int	already_dead;

	pthread_mutex_lock(philo->table->lock_is_dead);
	already_dead = *philo->is_dead;
	if (!already_dead)
	{
		*philo->is_dead = 1;
		pthread_mutex_unlock(philo->table->lock_is_dead);
		print_state(philo, "died");
		return (1);
	}
	pthread_mutex_unlock(philo->table->lock_is_dead);
	return (0);
}

int	check_any_philo_dead(t_philos *philos)
{
	size_t	i;

	i = 0;
	while (i < philos[0].nb_of_philos)
	{
		pthread_mutex_lock(philos[0].table->lock_is_dead);
		if (*philos[0].is_dead)
		{
			pthread_mutex_unlock(philos[0].table->lock_is_dead);
			return (1);
		}
		pthread_mutex_unlock(philos[0].table->lock_is_dead);
		if (philo_has_starved(&philos[i]))
			return (philo_has_died(&philos[i]));
		i++;
	}
	return (0);
}

int	are_all_philos_full(t_philos *philos)
{
	size_t	i;
	int		full_count;

	i = 0;
	full_count = 0;
	while (i < philos[0].nb_of_philos)
	{
		pthread_mutex_lock(philos[i].lock_meal_count);
		if (philos[0].table->total_meal != -1 &&
			philos[i].has_eaten >= philos[0].table->total_meal)
			full_count++;
		pthread_mutex_unlock(philos[i].lock_meal_count);
		i++;
	}
	if (full_count == (int)philos[0].nb_of_philos)
	{
		pthread_mutex_lock(philos[0].table->lock_is_dead);
		if (!*philos[0].is_dead)
		{
			*philos[0].is_dead = 1;
			pthread_mutex_unlock(philos[0].table->lock_is_dead);
			printf(PHILOS_FULL, philos->table->total_meal);
		}
		else
			pthread_mutex_unlock(philos[0].table->lock_is_dead);
		return (1);
	}
	return (0);
}

void	*state_checker(void *arg)
{
	t_philos	*philos = (t_philos *)arg;

	while (1)
	{
		if (check_any_philo_dead(philos) || are_all_philos_full(philos))
			break ;
		helper_usleep(10);
	}
	return (NULL);
}



âœ… Ã€ faire ailleurs dans ton projet (si pas dÃ©jÃ  fait)
ProtÃ©ger les printf() concurrents via un mutex lock_print, sinon tu peux avoir des sorties imbriquÃ©es.

VÃ©rifier que toutes les structures partagÃ©es (is_dead, last_meal, has_eaten) sont accessibles uniquement via mutex.

Si plusieurs threads appellent print_state, encapsule printf() dans une section critique.

TJSSSSS LOCK DANS LE MEME SENS

Tu pourrais inverser les deux pthread_mutex_lock() pour Ã©viter le risque de deadlock si d'autres fonctions lock lock_is_dead avant mutex. Toujours locker dans le mÃªme ordre dans tout le projet.

pthread_mutex_lock(philo->table->lock_is_dead);
pthread_mutex_lock(&philo->table->mutex);
...
pthread_mutex_unlock(&philo->table->mutex);
pthread_mutex_unlock(philo->table->lock_is_dead);

-------

ðŸ” 2. dinner_begin() :
âœ… Câ€™est correct :
Tu crÃ©es tous les threads (philo + state_checker) aprÃ¨s avoir initialisÃ© les valeurs partagÃ©es (via init_starting_time()).

Tu attends tous les threads via pthread_join() avant dâ€™appeler dinner_over.

âš ï¸ Point Ã  surveiller :
Sâ€™assurer que init_starting_time() initialise bien tous les champs partagÃ©s avant que le moindre thread les lise (sinon risque de race au lancement).

ðŸ” 3. dinner_over() :
âš ï¸ Attention :
Tu fais des destroy et free de mutex dynamiquement allouÃ©s sans vÃ©rifier que tous les threads sont terminÃ©s. Cependant, dans dinner_begin() tu fais bien les join, donc câ€™est sÃ»r dans ce contexte prÃ©cis.

âœ… Bonne pratique :
Tu free() et destroy() chaque mutex proprement.

Tu free() les locks dynamiques (lock_last_meal, etc.).

âœ… Conseil optionnel :
Si tu veux vraiment bÃ©tonner la gestion mÃ©moire :

Mets Ã  NULL les pointeurs aprÃ¨s free() pour Ã©viter les doubles free par erreur.

VÃ©rifie que les pthread_mutex_destroy() ne retournent pas une erreur (par sÃ©curitÃ©).

âœ… Conclusion gÃ©nÃ©rale :
Tu as bien gÃ©rÃ© :

La synchronisation de l'affichage (print_state).

La protection de *is_dead.

Le dÃ©marrage/arrÃªt propre des threads (dinner_begin, dinner_over).

Lâ€™accÃ¨s Ã  tous les champs partagÃ©s via des mutex appropriÃ©s.

âœ… Tu nâ€™as plus de data races ici.
Juste :

Inverse lâ€™ordre des lock dans print_state pour Ã©viter un deadlock potentiel.

Sois sÃ»r que tous les malloc() pour les mutex sont OK et bien initialisÃ©s avant toute utilisation.

Si tu veux, je peux relire routine() ou init_starting_time() pour te confirmer que tout est OK lÃ  aussi.

-------------

âŒ Exemple dangereux (risque de deadlock) :
Imaginons que tu as deux mutex : A et B.

Thread 1 fait :

c
Copier
Modifier
pthread_mutex_lock(&A);
pthread_mutex_lock(&B);
Thread 2 fait :

c
Copier
Modifier
pthread_mutex_lock(&B);
pthread_mutex_lock(&A);
ðŸ‘‰ Si Thread 1 lock A et attend B,
pendant que Thread 2 lock B et attend A,
alors plus aucun des deux ne pourra avancer : câ€™est un deadlock (blocage mutuel).

âœ… Solution sÃ»re : toujours les verrouiller dans le mÃªme ordre
Par exemple :

Tu dÃ©cides que lâ€™ordre des mutex est toujours A â†’ B

Donc tous les threads doivent faire :

c
Copier
Modifier
pthread_mutex_lock(&A);
pthread_mutex_lock(&B);
/* section critique */
pthread_mutex_unlock(&B);
pthread_mutex_unlock(&A);
ðŸ” Application Ã  ton code
Dans ta fonction print_state() tu as ceci :

c
Copier
Modifier
pthread_mutex_lock(&philo->table->mutex);
pthread_mutex_lock(philo->table->lock_is_dead);
Mais dans philo_has_died(), tu fais :

c
Copier
Modifier
pthread_mutex_lock(philo->table->lock_is_dead);
/* ... */
pthread_mutex_unlock(philo->table->lock_is_dead);
print_state(...);
Donc si print_state() re-lock mutex Ã  l'intÃ©rieur, tu pourrais te retrouver dans une situation de deadlock si un thread a dÃ©jÃ  lock_is_dead et l'autre a dÃ©jÃ  mutex.

âœ… Pour Ãªtre sÃ»r :
Tu dois choisir un ordre de verrouillage unique et cohÃ©rent partout. Par exemple :

ðŸ”’ Toujours : lock_is_dead â†’ mutex

Alors, dans toutes les fonctions oÃ¹ tu dois locker les deux, tu fais :

pthread_mutex_lock(philo->table->lock_is_dead);
pthread_mutex_lock(&philo->table->mutex);
/* ... */
pthread_mutex_unlock(&philo->table->mutex);
pthread_mutex_unlock(philo->table->lock_is_dead);
ðŸ“Œ RÃ©sumÃ©
ðŸ” Toujours locker dans le mÃªme ordre, sinon = deadlock possible.

âœ… Choisis un ordre clair (par ex. lock_is_dead â†’ mutex) et respecte-le partout.

â— Ceci est essentiel dÃ¨s que tu as plus dâ€™un mutex dans une section critique.

Si tu veux, je peux passer en revue toutes tes fonctions pour te dire si lâ€™ordre est cohÃ©rent partout.

------------------

ðŸŸ¡ Petite remarque Ã  corriger (typo)
Dans init_invited_philos() :

philos->lock_meal_count = (pthread_mutex_t *) malloc(sizeof(pthread_mutex_t));
if (!philos->lock_has_eaten) // âŒ erreur
    return ;
Tu testes lock_has_eaten deux fois, alors que tu viens dâ€™allouer lock_meal_count.
ðŸ‘‰ Corriger en :

if (!philos->lock_meal_count)
    return ;

----------------------

1. Synchroniser le point 0	starting_time = current_time() + 50;
2. Dans routine()	Attendre le vrai dÃ©part avec un while()
3. Mesurer tout en now - starting_time	Ne jamais afficher current_time() brut
4. Optionnel	Remplacer usleep() par nanosleep() si besoin

-----------------

void	*routine(void *arg)
{
	t_philos *philo = (t_philos *)arg;

	// Attente active avant lancement
	while ((long)(current_time() - philo->table->starting_time) < 0)
		usleep(50);

	// Ã€ ce stade, tout le monde commence "Ã  0"
	print_state(philo, "THINK");
	// ...
}

-----------------

Et dans init_starting_time() :

table->starting_time = current_time() + 50;

-----------------------

usleep 500 ds le utils, 1 dans le reste
